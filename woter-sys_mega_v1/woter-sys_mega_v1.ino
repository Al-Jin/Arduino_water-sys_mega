#include <Ultrasonic.h>                 // Подключаем библиотеку для работы с дальномером переделана в миллиметрах
#include <iarduino_DHT.h>               // Подключаем библиотеку для работы с датчиком DHT
#include <UTFT.h>                       //Подключаем библиотеку для работы с tft дисплеем
//Цифровой D0 - пустой

#define FlowSensorPin 2 // Датчик потока (расхода воды) подключен к цифровому выходу D2

//Цифровой D3 - пустой

Ultrasonic ultrasonic(4, 5);      // Trig - 2, Echo - 3 дальномер
#define SEN_IN 6                  // Подключение датчика перелива к цифровому выходу D4
iarduino_DHT AM2320(7);           // Объявляем объект датчик температуры и влажности, указывая номер вывода, к которому подключён модуль
#define LED_p_in1 8               // Подключение светодиода утечки воды к цифровому выходу D6
#define buttonPin1 9              // Кнопка отключения светодиода перелива воды к цифровому выходу D7
#define LED_p_in2 10               // Светодиод когда давление воды на входе 0 подключен к цифровому выводу D8
#define buttonPin2 11              // Кнопка отключения светодиода отсутствия давления воды на входе подключена к цифровому выводу D9
#define LED_p_in3 12              // Светодиод перекрытия воды на улицу подключен к цифровому выводу D10
#define buttonPin3 13             // Кнопка светодиода закрытия воды на улицу подключена к цифровому выводу D11

UTFT myGLCD(ILI9488,38,39,40,41);   //Инициализируем подключение tft дисплея MAR3951,38,39,40,41

#define DP 54                      // Датчик давления на входе подключен к аналоговому выводу A0
#define buttonPin4 55                      // Кнопка увеличения полива подключена к аналоговому выводу A1
#define buttonPin5 56                      // Кнопка уменьшения полива подключена к аналоговому выводу A2
#define buttonPin6 57                      // Кнопка ввода полива подключена к аналоговому выводу A3

#define RELEY_Ul_On 62            // Реле закрытия подачи воды на улицу к цифровому выходу D62, оранжевый
#define RELEY_Ul_Off 63           // Реле открытия подачи воды на улицу к цифровому выходу D63, желтый
#define RELEY_In_On 64            // Реле закрытия подачи воды в баки к цифровому выходу D64, синий
#define RELEY_In_Off 65           // Реле открытия подачи воды в баки к цифровому выходу D65, фиолетовый

extern uint8_t SmallFont[];              // Добавляем маленький шрифт
extern uint8_t Arial_round_16x24[];      // Новый шрифт: файл шрифта в папке скетча
extern uint8_t Inconsola[];              // Новый шрифт: файл шрифта в папке скетча
extern uint8_t Arial_bold_16x16[];       // Новый шрифт: файл шрифта в папке скетча
extern uint8_t ArialNumFontPlus[];       // Новый шрифт: файл шрифта в папке скетча
extern unsigned int panda[0x1D88];       // Массив с картинкой Панда: файл картинки в папке скетча

uint8_t K1 = 0;              // Коэффициент горения светодиода отсутствия давления воды на входе  
uint8_t K2 = 0;              // Коэффициент включения времени мигания светодиода
uint8_t K3 = 0;              // Коэффициент горения светодиода перелива
uint8_t K4 = 0;              // Коэффициент отсчета времени включения светодиода давления воды
uint8_t K5 = 0;              // Коэффициент горения светодиода перекрытия воды на улицу
uint8_t KinOn = 1;           // Коэффициент открытия подачи воды в бак
uint8_t KinOff = 0;          // Коэффициент закрытия подачи воды в бак
uint8_t KUlOn = 1;           // Коэффициент открытия подачи воды на улицу
uint8_t KUlOff = 0;          // Коэффициент закрытия подачи воды на улицу
uint8_t Kpoliv = 0;          // Коэффициент полива
uint8_t Kpoliv1 = 0;         // Коэффициент включения индикации полива
uint8_t Kpoliv_cancel = 0;   // Коэффициент отмены полива после ввода
uint8_t Kpanda = 0;          // Коэффициент картинки Панда
uint8_t K_on = 1;            // Коэффициент для выполнения действия один раз при включении
uint8_t K_pot_on = 1;        // Коэффициент идикации включения воды на улице
uint8_t K_pot_off = 1;       // Коэффициент идикации включения воды на улице

uint8_t buttonState1 = 0;    // Переменная для хранения состояния кнопки отключения светодиода перелива
uint8_t buttonState2 = 0;    // Переменная для хранения состояния кнопки отключения светодиода отсутствия давления воды на входе
uint8_t buttonState3 = 0;    // Переменная для хранения состояния кнопки отключения светодиода перекрытия воды на улицу
uint8_t buttonState4 = 0;    // Переменная для хранения состояния кнопки увеличения полива
uint8_t buttonState5 = 0;    // Переменная для хранения состояния кнопки уменьшения полива
uint8_t buttonState6 = 0;    // Переменная для хранения состояния кнопки ввода полива

uint32_t time0 = 0;   // Переменная для хранения точки отсчета в мигании светодиодом отсутствия воды
uint32_t time1 = 0;   // Переменная для хранения точки отсчета в для гашения светодиода при кратковременном отсутствии воды
uint32_t time2 = 0;   // Переменная для хранения точки отсчета в мигании светодиода перекрытия выды на улицу
uint32_t time3 = 0;   // Переменная для хранения точки отсчета считывания температуры и влажности
uint32_t time4 = 0;   // Переменная для хранения точки отсчета в мигании светодиода протечки
uint32_t time5 = 0;   // Переменная для хранения точки отсчета времени подачи воды
uint32_t time6 = 0;   // Переменная для хранения точки отсчета времени в вычислении медиан
uint32_t time7 = 0;   // Переменная для хранения точки отсчета времени для открытия подачи воды в бак
uint32_t time8 = 0;   // Переменная для хранения точки отсчета времени для закрытия подачи воды в бак
uint32_t time9 = 0;   // Переменная для хранения точки отсчета времени для открытия подачи воды на улицу
uint32_t time10 = 0;   // Переменная для хранения точки отсчета времени для закрытия подачи воды на улицу
uint32_t time11 = 0;   // Переменная для хранения точки отсчета времени для мигания значения полива до ввода
uint32_t time12 = 0;   // Переменная для хранения точки отсчета времени удаления полива, если не нажата кнопка ввод
uint32_t time13 = 0;   // Переменная для хранения точки отсчета времени при расчете скорости потока

float Hk = 0;              //Переменная влажности с учетом понижающего коэффициента
uint8_t s = 0;             // Переменная для хранения секунд времени с начала подачи воды
uint8_t m = 0;             // Переменная для хранения минут времени с начала подачи воды
uint8_t h = 0;             // Переменная для хранения часов времени с начала подачи воды
float p_in = 1;            // Переменная для хранения давления воды на входе
float distance[20];     // Массив для вычисления медианы данных с дальномера
float pr[20];           // Массив для вычисления медианы данных с датчика давления
int16_t V = 1000;
int16_t Vp = 100;
float H = 0;           // Высота воды в баке
int16_t Vv = 0;        // Для вычисления объема в литрах
int16_t Vvp = 0;       // Для вычисления объема в %
int16_t Y = 0;         // Вычисление координаты Y для прмоугольника с водой
int16_t Y1 = 0;        // Вычисление оординаты Y1 для прмоугольника с водой
float Median = 0;      //Для расчета медианы дальномера
float Median1 = 0;            //Для расчета медианы датчика давления
int16_t poliv = 0;            // Переменная для хранения количества литров полива
int16_t polivat = 0;              // Переменная для хранения сколько литров должно быть полито
uint32_t FlowSensor_puls = 0;     // Считает сколько импульсов пришло с датчика потока для вычисления потребленных литров
uint32_t FlowSensor_puls_Upot;    // Считает сколько импульсов пришло с датчика потока для вычисления скорости потока
float Upot = 0;                 // Скорость потока воды на улицу

void setup()
{
  attachInterrupt(0, FlowSensor_Function, RISING); // Обработчик прерываний для датчика потока. Датчик подключен к выводу D2
  
  Serial.begin(9600);                      // Инициируем передачу данных в монитор последовательного порта, на скорости 9600 бод
  myGLCD.InitLCD();                     // Объявляем дисплей
  myGLCD.clrScr();                      // Очищает экран и заливает черным цветом
   for (uint8_t i = 0; i < 20; i++) {              // Для вычисления медианы данных с дальномера
     distance[i] = ultrasonic.Ranging(MM);
   }
   
   for (uint8_t j = 0; j < 20; j++) {              // Для вычисления медианы данных с датчика давления
     pr[j] = analogRead(DP);
   } 

//При начале работы электрокраны должны быть открыты!!!!!
   
  pinMode(SEN_IN, INPUT);             // Датчик перелива
  pinMode(LED_p_in1, OUTPUT);         // Светодиод перелива
  pinMode(RELEY_In_On, OUTPUT);       // Реле открытия подачи воды в бак
  digitalWrite(RELEY_In_On, HIGH);    // Выключаем реле подачи воды в бак - посылаем высокий сигнал
  pinMode(RELEY_In_Off, OUTPUT);      // Реле закрытия подачи воды в бак
  digitalWrite(RELEY_In_Off, HIGH);   // Выключаем реле закрытия подачи воды в бак - посылаем высокий сигнал
  pinMode(RELEY_Ul_On, OUTPUT);       // Реле открытия подачи воды на улицу
  digitalWrite(RELEY_Ul_On, HIGH);    // Выключаем реле подачи воды на улицу - посылаем высокий сигнал
  pinMode(RELEY_Ul_Off, OUTPUT);      // Реле закрытия подачи воды на улицу
  digitalWrite(RELEY_Ul_Off, HIGH);   // Выключаем реле закрытия подачи воды на улицу - посылаем высокий сигнал
  pinMode(LED_p_in2, OUTPUT);         // Светодиод когда давление воды на входе 0
  pinMode(LED_p_in3, OUTPUT);         // Светодиод перекрытия воды на улицу
  pinMode(buttonPin1, INPUT);         // Инициализируем пин, подключенный к кнопке отключения светодиода перелива, как вход
  pinMode(buttonPin2, INPUT);         // Инициализируем пин, подключенный к кнопке отключения светодиода отсутствия давления воды на входе, как вход
  pinMode(buttonPin3, INPUT);         // Инициализируем пин, подключенный к кнопке отключения светодиода закрытия крана на улицу, как вход
  pinMode(buttonPin4, INPUT);         // Инициализируем пин, подключенный к кнопке увеличения полива, как вход
  pinMode(buttonPin5, INPUT);         // Инициализируем пин, подключенный к кнопке уменьшения полива, как вход
  pinMode(buttonPin6, INPUT);         // Инициализируем пин, подключенный к кнопке ввода полива, как вход
  pinMode(FlowSensorPin, INPUT);      // Инициализируем пин, подключенный к датчику потока, как вход

// Выводим один раз на экран постоянную информацию:
    myGLCD.setColor(255, 255, 255);           // Задаем цвет выводимого ниже на экран - белый 
    myGLCD.drawLine(330,80,330,300);          // Рисуем три линии обозначающие емкость
    myGLCD.drawLine(330,300,470,300);
    myGLCD.drawLine(470,80,470,300);
    myGLCD.drawLine(0,106,280,106);           // Рисуем линию отделяющую показания давления
    myGLCD.drawLine(0,215,280,215);           // Рисуем линию отделяющую показания температуры и влажности
    myGLCD.drawLine(210,216,210,320);         // Рисуем линию для отделния показаний открытой воды
    myGLCD.drawLine(211,267,279,267);         // Рисуем линию для отделния показаний открытой воды
    myGLCD.drawLine(280,0,280,320);           // Рисуем вертикальную линию, разделяющую показания
    myGLCD.drawLine(285,99,329,99);           // Рисуем линию на уровне полных баков
    myGLCD.drawLine(319,150,329,150);         // Рисуем линию на уровне 3/4 баков
    myGLCD.drawLine(285,200,329,200);         // Рисуем линию на уровне половины баков
    myGLCD.drawLine(319,250,329,250);         // Рисуем линию на уровне четверти баков
    myGLCD.setFont(SmallFont);                //Задаем шрифт выводимого ниже на экран
    myGLCD.print("100%", 290, 87);            //Выводим текст в кавычках
    myGLCD.print("50%", 295, 187);            //Выводим текст в кавычках
    myGLCD.setFont(Arial_round_16x24);        //Задаем шрифт выводимого ниже на экран
    myGLCD.print("P:", 10, 20);               //Выводим текст в кавычках
    myGLCD.print("bar", 130, 20);             //Выводим текст в кавычках
    myGLCD.print("T:", 10, 235);              //Выводим текст в кавычках
    myGLCD.print("`C", 130, 235);             //Выводим текст в кавычках
    myGLCD.print("H:", 10, 280);              //Выводим текст в кавычках
    myGLCD.print("%", 130, 280);              //Выводим текст в кавычках
    myGLCD.print("V:", 340, 45);              //Выводим текст в кавычках
    myGLCD.print("L", 447, 45);               //Выводим текст в кавычках
    myGLCD.print("%", 435, 10);               //Выводим текст в кавычках
}

void FlowSensor_Function(){
 ++FlowSensor_puls;          // Для вычисления потребленных литров
 ++FlowSensor_puls_Upot;     // Для выычисления скорости потока
}

void loop()
{
//    myGLCD.clrScr();                      // Очищает экран и заливает черным цветом

if(K_on == 1 && millis() < 30000){          // Условие принудительного открытия кранов при включении 30 секунд
  digitalWrite(RELEY_In_On, LOW);           //Включение реле открытия крана подачи воды
  digitalWrite(RELEY_Ul_On, LOW);           //Включение реле открытия крана подачи воды на улицу
}

buttonState1 = digitalRead(buttonPin1);                // Считваем значения с кнопки отключения светодиода перелива  
buttonState2 = digitalRead(buttonPin2);                // Считваем значения с кнопки отключения светодиода отсутствия давления воды на входе
buttonState3 = digitalRead(buttonPin3);                // Считваем значения с кнопки отключения светодиода перекрытия воды на улицу
buttonState4 = digitalRead(buttonPin4);                // Считваем значения с кнопки увеличения полива
buttonState5 = digitalRead(buttonPin5);                // Считваем значения с кнопки уменьшения полива
buttonState6 = digitalRead(buttonPin6);                // Считваем значения с кнопки ввода полива

if(buttonState1 == HIGH){                          // Условие отключения светодиода перелива при нажатии кнопки
    K3 = 0;                                          // Обнуление коэффициента, чтобы светодиод потух
    digitalWrite(LED_p_in1, LOW);
  }

if(buttonState2 == HIGH){                          // Условие отключения светодиода давления воды ноль на входе при нажатии кнопки
    K1 = 0;                                          // Обнуление коэффициента, чтобы светодиод потух
    K2 = 0;
    K4 = 0;
    digitalWrite(LED_p_in2, LOW);
    myGLCD.setFont(Arial_round_16x24);      //Задаем шрифт выводимого ниже на экран
    myGLCD.print("               ", 10, 70);           //Выводим пробелы, чтобы убрать время с момента подачи воды
  }

if(buttonState3 == HIGH){                          // Условие отключения светодиода перекрытия воды на улицу при нажатии кнопки
    K5 = 0;                                          // Обнуление коэффициента, чтобы светодиод потух
    digitalWrite(LED_p_in3, LOW);
  }
  
if(buttonState4 == HIGH && Kpoliv == 0){                   // Условие активации ввода полива
    poliv = poliv + 100;                                   // Увеличение литров полива
    Kpoliv1 = 1;
    time12 = millis();                                     // Начало отсчета минуты до удаления полива, если не введен ввод
  }

if(buttonState5 == HIGH && Kpoliv == 0 && Kpoliv1 == 1){   // Условие уменьшения литров полива
    poliv = poliv - 100;                                  // Уменьшение литров полива
    time12 = millis();                                    // Начало отсчета минуты до удаления полива, если не введен ввод
  }

if(buttonState6 == HIGH && Kpoliv == 0 && poliv > 99){                   // Условие ввода и начала полива
    Kpoliv = 1;
    Kpoliv1 = 0;
    FlowSensor_puls = 0;
    polivat = poliv;
  }

if(buttonState6 == HIGH && Kpoliv == 1){        // Условие удержания кгопки ввод для отмены
    ++Kpoliv_cancel;                            // Увеличение коэффициента на 1 
  }

if(Kpoliv == 1){
  poliv = polivat - FlowSensor_puls / 439;    // Подсчет израсходованных литров. В 1 литре 439 импульсов
}

if(poliv < 0){                   // Проверка чтобы полив не уходил в отрицательное число
    poliv = 0;
  }

if(poliv == 0 && Kpoliv == 1){     // Условие перекрытия крана на улицу при окончании полива
  K5 = 1;
//  Kpoliv = 0;
}

if(poliv > 0 && K5 == 1 && V > (poliv + 400 + 50)){    // Условие открытия крана на улицу, если полив не закончен/ 400 минимальное кол-во для дома + 50 запас
  K5 = 0;
}

if(buttonState3 == HIGH && Kpoliv == 1 && poliv == 0){   // Условие окончания полива при нажатии кнопки открытия крана на улицу
  K5 = 0;
  Kpoliv = 0;
  Kpoliv_cancel = 0;
  Kpanda = 0;
}

//Serial.println(i);
//Serial.println();
//Serial.println("***********************");

if(millis() - time3 > 3000){       // Условие опроса датчика температуры и влажности раз в 3 секунды
    switch(AM2320.read());           //Считываем температуру и влажность
    time3 = millis();
  }
  
Hk = AM2320.hum * 0.7;    // Поправочный коэффициент влажности, был 0.73

if(digitalRead(SEN_IN) == LOW){    // Условие включения светодиода при протечке
    digitalWrite(LED_p_in1, HIGH);
    K3 = 1;
  }

if(V < 400){                            // Условие включения светодиода перекрытия воды на улицу
    digitalWrite(LED_p_in3, HIGH);
    K5 = 1;
  }
  
  if (millis() > 60000) {        // Условие игнорирующее открытие или закрытие кранов в первые 60 секунд работы программы
    K_on = 0;   // Обнуление коэффициента выполнения действий при включении
    if ((KinOff == 0 && K1 == 1) || (KinOff == 0 && K3 == 1)) {  //Условия закрытия крана подачи воды
      time8 = millis();
      KinOff = 1;
      KinOn = 0;
    }
    if ((KinOn == 0 && K1 == 0 && K3 == 0)) {  //Условия открытия крана подачи воды
      time7 = millis();
      KinOff = 0;
      KinOn = 1;
    } 
    if ((K1 == 1 && (millis() - time8) < 20000) || (K3 == 1 && (millis() - time8) < 20000)) {  // Подача напряжения на электро кран для закрытия подачи воды в бак 20 секунд
     digitalWrite(RELEY_In_Off, LOW);   //Включение реле закрытия крана подачи воды
    } else {
      digitalWrite(RELEY_In_Off, HIGH);
   }
   if ((K1 == 0 && millis() - time7 < 20000) || (K3 == 0 && millis() - time7 < 20000)) {  // Подача напряжения на электро кран для открытия подачи воды в бак 20 секунд
   digitalWrite(RELEY_In_On, LOW);   //Включение реле открытия крана подачи воды
   } else {
   digitalWrite(RELEY_In_On, HIGH);
    }
   if (KUlOn == 0 && K5 == 0) {  //Условия открытия крана подачи воды на улицу
      time9 = millis();
      KUlOff = 0;
      KUlOn = 1;
   }
   if (KUlOff == 0 && K5 == 1) {  //Условия закрытия крана подачи воды на улицу
      time10 = millis();
      KUlOff = 1;
      KUlOn = 0;
   }
   if (K5 == 1 && (millis() - time10) < 20000) {                       // Подача напряжения на электро кран для закрытия подачи воды на улицу 20 секунд
     digitalWrite(RELEY_Ul_Off, LOW);                   //Включение реле закрытия крана подачи воды на улицу
    } else {
      digitalWrite(RELEY_Ul_Off, HIGH);
   }
   if (K5 == 0 && millis() - time9 < 20000) {  // Подача напряжения на электро кран для открытия подачи воды на улицу 20 секунд
   digitalWrite(RELEY_Ul_On, LOW);                              //Включение реле открытия крана подачи воды на улицу
   } else {
   digitalWrite(RELEY_Ul_On, HIGH);
    } 
  }
  
  if(digitalRead(SEN_IN) != LOW && K3 > 0 && millis() - time4 > 500){       // Условие мигания светодиода протечки при понижении уровня воды до нормального
    digitalWrite(LED_p_in1, !digitalRead(LED_p_in1));        // включаем / выключаем LED
    time4 = millis();
  }  

  if(V > 500 && K5 > 0 && millis() - time2 > 500){       // Условие мигания светодиода перекрытия воды на улицу при повышении уровня воды до нормального
    digitalWrite(LED_p_in3, !digitalRead(LED_p_in3));        // включаем / выключаем LED
    time2 = millis();
  }  

if(p_in == 0 && K4 == 0){       // Изменение значения переменной для отсчета включения светодиода когда давление воды на входе равно 0
    time1 = millis();
    K4 = 1;
  } 

if(p_in > 0){       // Изменение значения переменной для отсчета включения светодиода когда давление воды на входе равно 0
    K4 = 0;
  } 

if(p_in == 0 && millis() - time1 > 600000 && K1 == 0){       // Условие включения светодиода когда давление воды на входе равно 0 в течении 10 минут 600000
    digitalWrite(LED_p_in2, HIGH);
    K1 = 1;                                 // Коэффициент, для мигания светодиода после подачи воды
  }

if(p_in > 0 && K1 > 0 && millis() - time0 > 500){          // Условие мигания светодиода после подачи воды
    digitalWrite(LED_p_in2, !digitalRead(LED_p_in2));      // включаем / выключаем LED
    time0 = millis();
  }  

if (p_in == 0 && K1 > 0){
  K2 = 0;
  digitalWrite(LED_p_in2, HIGH);
}

if(p_in > 0 && K1 > 0 && K2 == 0){              // Условие начала отсчета с момента подачи воды
  K2 = 1;
  s = 0;
  m = 0;
  h = 0;
  time5 = millis();  
  } 

if(millis() - time5 > 1000){
      time5 = millis();
        ++s;   //Отсчет 1 секунды
      }
      if(s > 59){
        s = 0;
        ++m;      // отсчет 1 мин
      }
      if(m > 59){
        m = 0;
        ++h; // отсчет 1 час
      }
      if(h > 23){
        h = 0;
      }

if(millis() - time6 > 150){             // Задержка опроса датчиков для вычисления медиан
distance[0] = ultrasonic.Ranging(MM);   //Новый замер дальномера
  //delay(150);
   uint8_t previous = 18;     // почему previous меньше current
   uint8_t current = 19;
   for (uint8_t i = 1; i < 20; i++) {             //Функция для обновления данных в массиве
    distance[current] = distance[previous];
     previous--;
     current--;
//     Serial.println(i);
//     Serial.println(previous);
//     Serial.println(current);
//     Serial.println("-------------------------"); 
   }
   bool leave = false;          //Функция для сортировки массива в порядке возрастания
  float temp;
   while (!leave) {
     leave = true;
     uint8_t i = 0;
     for (uint8_t counter = 0; counter < 19; counter++) {
       if (distance[i] > distance[i + 1]) {
         temp = distance[i];
         distance[i] = distance[i + 1];
         distance[i + 1] = temp;
         leave = false;
       }
       i++;
     }
   }
   
pr[0] = analogRead(DP);      // Новый замер датчика давления
  //delay(150);
   uint8_t previous1 = 18;
   uint8_t current1 = 19;
   for (uint8_t j = 1; j < 20; j++) {             //Функция для обновления данных в массиве
    pr[current1] = pr[previous1];
     previous1--;
     current1--;
   }
   bool leave1 = false;          //Функция для сортировки массива в порядке возрастания
  float temp1;
   while (!leave1) {
     leave1 = true;
     uint8_t j = 0;
     for (byte counter1 = 0; counter1 < 19; counter1++) {
       if (pr[j] > pr[j + 1]) {
         temp1 = pr[j];
         pr[j] = pr[j + 1];
         pr[j + 1] = temp1;
         leave1 = false;
       }
       j++;
     }
   }
   time6 = millis();
}

Median = (distance[9] + distance[10]) / 2; //расчет медианы дальномера
Median1 = (pr[9] + pr[10]) / 2;            //расчет медианы датчика давления

//Serial.println(analogRead(DP));

p_in = (Median1 - 92) * 1.2 / (882 - 92) * 10;     // Вычисляем давление воды на входе в bar
if(Median1 < 92){    // Условие когда давление равно 0
    p_in = 0;
  }
  
//if(p_in < 0.05){
//      p_in = 0;
//    }

//p_in = 0;

H = 1531-(Median - 135);           //Высота воды в баке
if (H < 0) {
  H = 0;
}

Vv = H*0.65316786;                  //Вычисляем объем в литрах, принимая что в 1 см 6,53 литра, в 1 мм 0,65 литра
Vvp = Vv*0.1;                       //Вычисляем объем в %

if (Vv > 1000) {
  V = 1000;
} else {
  V = Vv;
}
if (Vvp > 100)
{  Vp = 100;
} else{
  Vp = Vvp;
}

Y = 300-200*Vp*0.01;     //Вычисляем координату Y прямоугольника с водой
Y1 = Y-1;                //Вычисляем координату Y прямоугольника с водой

if(millis() - time13 > 1000){ // Если c момента последнего расчёта прошла 1 секунда
  Upot = FlowSensor_puls_Upot / 7.5;
  FlowSensor_puls_Upot = 0;
  time13 = millis();
}

//if(Upot > 0.1 && K_pot_on == 0){
//  K_pot_on = 0;
//  K_pot_off
//}
//if(Upot <= 0.1 && K_pot_off == 0){
//  K_pot_on = 0;
//  K_pot_off = 1;
//}

if(Upot > 0.1 && K_pot_on == 1){
  myGLCD.setColor(250, 0, 0);           // Задаем цвет выводимого ниже на экран - красный
  myGLCD.fillRect(211,216,279,266);     // Прямоугольник
  myGLCD.setColor(255, 255, 255);        // Задаем цвет выводимого ниже на экран - белый
  myGLCD.setBackColor(VGA_TRANSPARENT);        // Задаем цвет фона для надписи - прозрачный
  myGLCD.setFont(Arial_bold_16x16);     //Задаем шрифт выводимого ниже на экран
  myGLCD.print("UL", 230, 223);         //Выводим текст в кавычках
  myGLCD.print("ON", 230, 243);         //Выводим текст в кавычках
  K_pot_on = 0;
  K_pot_off = 1;
} 
if(Upot <= 0.1 && K_pot_off == 1){
  myGLCD.setColor(0, 150, 0);           // Задаем цвет выводимого ниже на экран - зеленый
  myGLCD.fillRect(211,216,279,266);     // Прямоугольник
  myGLCD.setColor(255, 255, 255);        // Задаем цвет выводимого ниже на экран - белый
  myGLCD.setBackColor(VGA_TRANSPARENT);  // Задаем цвет фона для надписи - прозрачный
  myGLCD.setFont(Arial_bold_16x16);     //Задаем шрифт выводимого ниже на экран
  myGLCD.print("UL", 230, 223);         //Выводим текст в кавычках
  myGLCD.print("OFF", 220, 243);         //Выводим текст в кавычках
  K_pot_on = 1;
  K_pot_off = 0;
}

    myGLCD.setColor(255, 255, 255);        // Задаем цвет выводимого ниже на экран - белый
    myGLCD.setBackColor(0, 0, 0);         // Возвращает цвет фона для текста - черный
    myGLCD.setFont(Arial_round_16x24);   //Задаем шрифт выводимого ниже на экран

if(p_in > 0 && K1 > 0){                   // Условие вывода времена с момента подачи воды на входе
    myGLCD.print("P>0:", 10, 70);         //Выводим текст в кавычках
    myGLCD.print(":", 120, 70);           //Выводим текст в кавычках        
    if(h < 10){                           // Обнуление второго разряда часов
    myGLCD.printNumI(0, 85, 70);
    myGLCD.printNumI(h, 102, 70);
  }   else {
    myGLCD.printNumI(h, 85, 70);
  } if(m < 10){                         // Обнуление второго разряда минут
    myGLCD.printNumI(0, 136, 70);
    myGLCD.printNumI(m, 153, 70);
  }   else {
    myGLCD.printNumI(m, 136, 70);
  } if(s < 10){                         // Обнуление второго разряда минут
    myGLCD.setFont(Arial_bold_16x16);   //Задаем шрифт выводимого ниже на экран
    myGLCD.printNumI(0, 175, 75);
    myGLCD.printNumI(s, 192, 75);
  }   else {
    myGLCD.setFont(Arial_bold_16x16);   //Задаем шрифт выводимого ниже на экран
    myGLCD.printNumI(s, 175, 75);
  }} else {
    myGLCD.setFont(Arial_round_16x24);   //Задаем шрифт выводимого ниже на экран
    myGLCD.print("               ", 10, 70);           //Выводим пробелы, чтобы убрать время с момента подачи воды
  }

myGLCD.setFont(Arial_round_16x24);   //Задаем шрифт выводимого ниже на экран

if(Kpanda == 0){                         // Выводим Панду
  myGLCD.drawBitmap(0, 107, 140, 54, panda, 2); // Выводим картинку Панда
}

if(Kpanda == 0 && Kpoliv1 == 1){               // Закрашиваем Панду
    myGLCD.setColor(0, 0, 0);                  // Задаем черный цвет прямоугольника
    myGLCD.fillRect(0,107,279,213);            // Рисуем прямоугольник, для закрашивания Панды
    Kpanda = 1;
  }

if(Kpoliv1 == 1 && Kpanda == 1){
  if(millis() - time11 > 1000 && Kpoliv1 == 1){       // Условие вывода информации полив на экран раз в секунду - мигание
    time11 = millis();
    myGLCD.setColor(255, 255, 255);                  // Задаем цвет выводимого ниже на экран - белый
    myGLCD.print("Vpoliv:", 10, 152);             //Выводим текст в кавычках
    myGLCD.print("L", 247, 150);                  //Выводим текст в кавычках
    myGLCD.setFont(ArialNumFontPlus);             //Задаем шрифт выводимого ниже на экран
    myGLCD.printNumI(poliv, 130, 133);             //Выводим текст в кавычках 
    } else {
      myGLCD.setColor(0, 0, 0);                  // Задаем черный цвет прямоугольника
      myGLCD.fillRect(130,126,270,210);           // Рисуем прямоугольник, для закрашивания цифры полива
    }
}

if(millis() - time12 > 120000 && Kpoliv1 == 1){       // Условие прекращения ввода полив, если не нажали ввод за 2 минуты
    Kpoliv1 = 0;
    poliv = 0;
    Kpanda =0;
    myGLCD.drawBitmap(0, 107, 140, 54, panda, 2); // Выводим картинку Панда
  }

if(Kpoliv_cancel == 5){                          // Условие отмены полива после ввода
   myGLCD.drawBitmap(0, 107, 140, 54, panda, 2); // Выводим картинку Панда  
   Kpoliv = 0; 
   Kpoliv1 = 0;
   Kpoliv_cancel = 0;
   poliv = 0;
   Kpanda = 0;                            
  }

if(Kpoliv == 1){
  myGLCD.setColor(255, 255, 255);                  // Задаем цвет выводимого ниже на экран - белый
  myGLCD.print("Vpoliv:", 10, 152);             //Выводим текст в кавычках
  myGLCD.print("L", 247, 150);              //Выводим текст в кавычках
     if(poliv < 10) {                               // Условие центровки разрядов правее, так как в шрифте нет пробелов
       myGLCD.setColor(0, 0, 0);                   // Задаем черный цвет прямоугольника
       myGLCD.fillRect(162,133,194,183);             // Рисуем прямоугольник, для закрашивания десятков полива
       myGLCD.setColor(255, 255, 255);                  // Задаем цвет выводимого ниже на экран - белый
       myGLCD.setFont(ArialNumFontPlus);             //Задаем шрифт выводимого ниже на экран
       myGLCD.printNumI(poliv, 192, 133);             //Выводим текст в кавычка
     } else if(poliv < 100) {
             myGLCD.setColor(0, 0, 0);                   // Задаем черный цвет прямоугольника
             myGLCD.fillRect(130,133,162,183);             // Рисуем прямоугольник, для закрашивания сотен полива
             myGLCD.setColor(255, 255, 255);                  // Задаем цвет выводимого ниже на экран - белый
             myGLCD.setFont(ArialNumFontPlus);             //Задаем шрифт выводимого ниже на экран
             myGLCD.printNumI(poliv, 162, 133);             //Выводим текст в кавычках 
     } else {
      myGLCD.setColor(255, 255, 255);                  // Задаем цвет выводимого ниже на экран - белый
      myGLCD.setFont(ArialNumFontPlus);             //Задаем шрифт выводимого ниже на экран
      myGLCD.printNumI(poliv, 130, 133);             //Выводим текст в кавычках
     } 
}
      
    myGLCD.setColor(255, 255, 255);        // Задаем цвет выводимого ниже на экран - белый  
    myGLCD.setFont(Arial_round_16x24);              //Задаем шрифт выводимого ниже на экран
//    myGLCD.drawLine(0,106,280,106);           // Рисуем линию отделяющую показания давления
//    myGLCD.drawLine(0,215,280,215);           // Рисуем линию отделяющую показания температуры и влажности
//    myGLCD.drawLine(210,216,210,320);           // Рисуем линию для отделния показаний открытой воды
//    myGLCD.drawLine(211,267,279,267);           // Рисуем линию для отделния показаний открытой воды
    
//    myGLCD.print("P:", 10, 20);                    //Выводим текст в кавычках
//    myGLCD.print("bar", 130, 20);                  //Выводим текст в кавычках
    myGLCD.printNumF(p_in, 2, 50, 20);             //Выводим значение давления на входе
//    myGLCD.print("T:", 10, 235);                   //Выводим текст в кавычках
//    myGLCD.print("`C", 130, 235);                  //Выводим текст в кавычках
    myGLCD.printNumF(AM2320.tem, 1, 50, 235);      //Выводим значение температуры в подвале
//    myGLCD.print("H:", 10, 280);                   //Выводим текст в кавычках
//    myGLCD.print("%", 130, 280);                   //Выводим текст в кавычках
    myGLCD.printNumF(Hk, 1, 50, 280);              //Выводим значение влажности в подвале
//    myGLCD.print("V:", 340, 45);                   //Выводим текст в кавычках
//    myGLCD.print("L", 447, 45);                    //Выводим текст в кавычках
    myGLCD.printNumI(V, 375, 45, 4);                  //Выводим значение количества воды в баках
//    myGLCD.print("%", 435, 10);                    //Выводим текст в кавычках
    myGLCD.printNumI(Vp, 377, 10, 3);                 //Выводим значение количества воды в баках в %
    
    //myGLCD.drawLine(330,80,330,300);           // Рисуем три линии обозначающие емкость
    //myGLCD.drawLine(330,300,470,300);
    //myGLCD.drawLine(470,80,470,300);
//    myGLCD.drawLine(285,99,329,99);            // Рисуем линию на уровне полных баков
//    myGLCD.drawLine(319,150,329,150);          // Рисуем линию на уровне 3/4 баков
//    myGLCD.drawLine(285,200,329,200);          // Рисуем линию на уровне половины баков
//    myGLCD.drawLine(319,250,329,250);          // Рисуем линию на уровне четверти баков
//    myGLCD.setFont(SmallFont);                 //Задаем шрифт выводимого ниже на экран
//    myGLCD.print("100%", 290, 87);             //Выводим текст в кавычках
//    myGLCD.print("50%", 295, 187);             //Выводим текст в кавычках
//    myGLCD.drawLine(280,0,280,320);           // Рисуем вертикальную линию, разделяющую показания    
    if (V < 200) {
      myGLCD.setColor(250, 0, 0);             // Задаем красный цвет прямоугольника с водой   
    } else {
      if (V < 500) {
      myGLCD.setColor(247, 236, 22);            // Задаем желтый цвет прямоугольника с водой    
    } else {
      myGLCD.setColor(35, 144, 252);            // Задаем синий цвет прямоугольника с водой
      }
    }
    myGLCD.fillRect(331,299,469,Y);            // Рисуем прямоугольник, показывающий уровень воды
    if (Vp < 100) {
    myGLCD.setColor(0, 0, 0);                  // Задаем черный цвет прямоугольника
    myGLCD.fillRect(331,100,469,Y1);           // Рисуем прямоугольник, для закрашивания остатка прямоугольника уровня воды
    }
 
}
